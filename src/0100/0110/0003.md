## package.json

```js
{
  "dependencies": {
    "foo": "1.0.0 - 2.9999.9999",
    "bar": ">=1.0.2 <2.1.2",
    "baz": ">1.0.2 <=2.3.4",
    "boo": "2.0.1",
    "qux": "<1.0.0 || >=2.3.1 <2.4.5 || >=2.5.2 <3.0.0",
    "asd": "http://asdf.com/asdf.tar.gz",
    "til": "~1.2",
    "elf": "~1.2.3",
    "two": "2.x",
    "thr": "3.3.x",
    "lat": "latest",
    "dyl": "file:../dyl"
  }
}
```

### 语义化版本

- 主版本号：不兼容的 API 修改
- 次版本号：向下兼容的功能性新增
- 修订号：向下兼容的问题修正

- *：升级到最新版本
- ^：升级次版本号和修订号
- ~：只升级修订号


## NPM

### npm 包版本管理最佳实践

https://juejin.cn/post/6844903582337237006#heading-13
### npm link

作用：将npm 模块链接到对应的运行项目中去，方便地对模块进行调试和测试

1. 创建 a b 两个目录（mkdir a & mkdir b），并初始化项目为npm（npm init -y）
2. 进入 a 目录，创建 index.js，写一个 console.log('test')
3. 创建软链到全局 `npm link`
4. 如果是全局可执行的就直接可以用了，例如：yo your-project
5. 进入 b 目录，`npm link a`，这个时候就跟我们安装完依赖一样了，就直接导入使用就可以了
6. 这个时候修改 a 下面的内容，发现 b 目录下面的node_modules里面的内容也是随时更新的

注意：`link` 的时候要注意一下 `package.json` 里面的 `main` 字段的指向，可能`引用软链的时候找不到内容`，比如这个项目你只有打包之后才能产生这个文件
 
### npm unlink

通过 `npm unlink [package.json.name]`

如果上面命令不行的话,去系统里找到该包，进行删除

```js
where npm

cd ../

cd lib

cd node_modules

ls
// 我是mac上的，这个目录下能找到该包，然后进行删除，然后重新安装就可以使用已经发布的了
/Users/xueyou/.nvm/versions/node/v16.13.1/lib/node_modules 
```

### npm scripts

https://juejin.cn/post/6844903582337237006#heading-14

### npx

https://juejin.cn/post/6844903582337237006#heading-17


### npmrc 文件

https://juejin.cn/post/6844903582337237006#heading-23



## Yarn

Yarn 是在2016年开源的，yarn 的出现是为了解决 npm v3 中的存在的一些问题，那时 npm v5 还没发布。Yarn 被定义为快速、安全、可靠的依赖管理。

### Yarn lock vs. npm lock

- 文件格式不同，npm v5 使用的是 json 格式，yarn 使用的是自定义格式
- package-lock.json 文件里记录的依赖的版本都是确定的，不会出现语义化版本范围符号(~ ^ *)，而 yarn.lock 文件里仍然会出现语义化版本范围符号
- package-lock.json 文件内容更丰富，实现了更密集的锁文件，包括子依赖的提升信息
  - npm v5 只需要 package.lock 文件就可以确定 node_modules 目录结构
  - yarn.lock 无法确定顶层依赖，需要 package.json 和 yarn.lock 两个文件才能确定 node_modules 目录结构。node_modules 目录中 package 的位置是在 yarn 的内部计算出来的，在使用不同版本的 yarn 时可能会引起不确定性。


### Yarn v2 Plug'n'Play

在Yarn 的2.x版本重点推出了Plug'n'Play（PnP）零安装模式，放弃了node_modules，更加保证依赖的可靠性，构建速度也得到更大的提升。

- 优：摆脱node_modules，安装、模块速度加载快；所有 npm 模块都会存放在全局的缓存目录下，避免多重依赖；严格模式下子依赖不会提升，也避免了幽灵依赖（但这可能会导致某些包出现问题，因此也支持了依赖提升的宽松模式:<）。
- 缺：自建resolver 处理Node require方法，执行Node文件需要通过yarn node解释器执行，脱离Node现存生态，兼容性不太好


## pnpm


## cnpm 和 tnpm

cnpm/tnpm的依赖管理是借鉴了pnpm ，通过符号链接方式创建非扁平化的node_modules结构，最大限度提高了安装速度

## 参考

npm Docs：https://docs.npmjs.com/cli/v8/configuring-npm/package-json

关于依赖管理的真相 — 前端包管理器探究：https://mp.weixin.qq.com/s/vcwgJ-5bkblNmZp5Iz4bxw

2018 年了，你还是只会 npm install 吗？：https://juejin.cn/post/6844903582337237006#heading-25

2222 年了，总不能还只会 npm i 吧?🔥：https://juejin.cn/post/7069701706606444551