### 队列 & 栈

队列是先入先出

栈的特点，后入先出，仅能使用 push 和 pop

### 时间复杂度

算法的时间复杂度就是说一个算法的执行时间根据数据规模增长的一个趋势，并不是说代码执行的具体时间

```js
// 大O表示法
// T代表的是算法需要执行的总时间
// S表示的算法需要的总空间
// f(n)表示的是代码执行的总次数
T(n) = O(f(n))
S(n) = O(f(n))
```

```js
function go(n) {
  var item = 0; // 这里执行了一次
  for (var i = 0; i < n; i++) {
    //这里执行了N次
    for (var j = 0; j < n; j++) {
      //这里执行了n*n次
      item = item + i + j; //这里执行了n*n次
    }
  }
  return item; //这里执行了一次
}
```

上边这段代码是 `1+n+n*n*2+1 = 2+n+2n²`

也就是说 `T(n) = O(f(2+n+2n²))`

规模比较大的时候，那些常量是起不到决定性的作用的，所以这个时候我们忽略这些常量，这里的例子是一个单段的代码，这里只看最大量级的循环就可以了

所以最后的这个代码的时间复杂度是`T(n) = O(n²)`

#### 几种常见的时间复杂度

##### T(n) = O(1)

```js
// 代码走一遍就完事
function total(n) {
  console.log(1);
}
```

##### T(n) = O(n)

```js
// 执行时间完全由N来控制
for (var i = 0; i < n; i++) {
  sum += i;
}
```

##### T(n) = O(n²)

```js
function go(i) {
  var sum = 0;
  for (var j = 0; j < i; j++) {
    sum += i;
  }
  return sum;
}
function main(n) {
  var res = 0;
  for (var i = 0; i < n; i++) {
    res = res + go(i); // 这里是重点
  }
}
```

go：（1+n）

在 main 函数里边的时候是`(1+n*go)= (1+n*(1+n))=(1+n+n*n)`

```js
// 当N接近无限大的时候n是对n²起不到决定性作用的，所以这块代码的时间复杂度就是取最大值的n²
function go(n) {
  for (var i = 0; i < n; i++) {
    for (var j = 0; j < n; j++) {
      console.log(1); // n²
    }
  }

  for (var i = 0; i < n; i++) {
    console.log(2); // n
  }
}
```

##### T(n)=O(logn)

```js
var i = 1;
while (i <= n) {
  i = i + 10;
}
```

判断条件的 i 被每次+10，那么所以说最后循环的次数并不是 n 次，而是说十分之一 n 次，所以说这个时候的时间复杂度是`10i=n`
`i=logn`

##### T(n) = O(m+n)

```js
// 函数里边有两个循环，但是形参有两个，我们现在无法得知n和m到底谁大谁小，所以说这个时候代码的时间复杂度是O(m+n)
function go(m, n) {
  for (var i = 0; i < n; i++) {
    console.log(1);
  }

  for (var i = 0; i < m; i++) {
    console.log(2);
  }
}
```

### 空间复杂度

空间复杂度就是指的占用内存的趋势

空间复杂度`(声明变量)`没有时间复杂度那么复杂，常见的就那么几种

- O(1)

```js
let a = 1;
let b = 1;
let c = 1;
let d = 1;
```

- O(n)

```js
// 数组的长度根据n来决定
let arr = Array(n);
```

- O(n²)

```js
// 别这么搞
let arr = [];
for (var i = 0; i < n; i++) {
  arr[i] = i;
  for (var j = 0; j < n; j++) {
    arr[i][j] = j;
  }
}
```

### 复杂度的优化

```js
console.time("a");
function go(n) {
  var item = 0;
  for (var i = 1; i <= n; i++) {
    item += i;
  }
  return item;
}
console.timeEnd("a");

console.time("b");
function go2(n) {
  var item = (n * (n + 1)) / 2;
  return item;
}
console.timeEnd("b");

go(1000);
go2(1000);
```

### 斐波那契数列

斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。

```js
function Fibonacci(n) {
  if (n <= 1 ) {
    return n;
  } else {
    return Fibonacci(n - 1) + Fibonacci(n - 2);
  }
}

console.time('b')
Fibonacci(????)
console.timeEnd('b')
```

https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/solution/fei-bo-na-qi-shu-lie-by-leetcode-solutio-hbss/