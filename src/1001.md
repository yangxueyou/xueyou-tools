### 共存的模块化标准

- `CommonJS`：现主要用于Node.js（Node@13.2.0开始支持直接使用ES Module）
- `AMD`：require.js 依赖前置，市场存量不建议使用
- `CMD`：sea.js 就近执行，市场存量不建议使用
- `ES Module`：ES语言规范，标准，趋势，未来

### 发展中的构建工具

- 2012：Webpack、Gulp/Browserify、Grunt
- 2015：Rollup
- 2018：parcel
- 2020：Snowpack、**Vite**

### 当前工程化痛点

现在常用的构建工具如`Webpack`，主要是通过抓取-编译-构建整个应用的代码（也就是常说的打包过程），生成一份编译、优化后能良好兼容各个浏览器的的生产环境代码。在开发环境流程也基本相同，需要先将整个应用构建打包后，再把打包后的代码交给`dev server（开发服务器）`。

`Webpack`等构建工具的诞生给前端开发带来了极大的便利，但随着前端业务的复杂化，js代码量呈指数增长，打包构建时间越来越久，`dev server（开发服务器）性能遇到瓶颈：`

- `缓慢的服务启动：` 大型项目中`dev server`启动时间达到几十秒甚至几分钟。
- `缓慢的HMR热更新：` 即使采用了 `HMR` 模式，其热更新速度也会随着应用规模的增长而显著下降，已达到性能瓶颈，无多少优化空间。

**缓慢的开发环境，大大降低了开发者的幸福感，在以上背景下Vite应运而生。**

### 什么是Vite？

基于`esbuild`与`Rollup`，依靠浏览器自身`ESM编译功能`， 实现极致开发体验的新一代构建工具！

先介绍以下文中会经常提到的一些基础概念：

- `依赖：` 指开发不会变动的部分(npm包、UI组件库)，`esbuild`进行预构建。
- `源码： `浏览器不能直接执行的非js代码(.jsx、.css、.vue等)，`vite`只在浏览器请求相关源码的时候进行转换，以提供ESM源码。

### 开发环境

- 利用浏览器原生的`ES Module`编译能力，省略费时的编译环节，直给浏览器开发环境源码，`dev server`只提供轻量服务。
- 浏览器执行ESM的`import`时，会向`dev server`发起该模块的`ajax请求`，服务器对源码做简单处理后返回给浏览器。
- `Vite`中HMR是在原生 ESM 上执行的。当编辑一个文件时，Vite 只需要精确地使已编辑的模块失活，使得无论应用大小如何，HMR 始终能保持快速更新。
- 使用`esbuild`处理项目依赖，`esbuild使用go编写`，比一般node.js编写的编译器快几个数量级。

### 生产环境

集成`Rollup`打包生产环境代码，依赖其成熟稳定的生态与更简洁的插件机制。

### 处理流程对比

- `Webpack`通过先将整个应用打包，再将打包后代码提供给`dev server`，开发者才能开始开发。
- `Vite`直接将源码交给浏览器，实现`dev server`秒开，浏览器显示页面需要相关模块时，再向`dev server`发起请求，服务器简单处理后，将该模块返回给浏览器，实现真正意义的按需加载。

### 基本用法

1. **创建vite项目**

```js
$ npm create vite@latest
```

2. **选取模板**

`Vite` 内置6种常用模板与对应的TS版本，可满足前端大部分开发场景，可以在 [StackBlitz](https://vite.new/) 中在线试用，还有其他更多的 [社区维护模板](https://github.com/vitejs/awesome-vite#templates)可以使用。

### 实现原理

1. **ESbuild 编译**

`esbuild` 使用`go`编写，`cpu密集`下更具性能优势，编译速度更快

2. **依赖预构建**

- `模块化兼容`： 如开头背景所写，现仍共存多种模块化标准代码，`Vite`在预构建阶段将依赖中各种其他模块化规范(CommonJS、UMD)转换 成`ESM`，以提供给浏览器。
- `性能优化`： npm包中大量的`ESM`代码，大量的`import`请求，会造成网络拥塞。`Vite使用esbuild`，将有大量内部模块的`ESM关系`转换成`单个模块`，以减少 `import`模块请求次数。

3. **按需加载**

服务器只在接受到import请求的时候，才会编译对应的文件，将ESM源码返回给浏览器，实现真正的按需加载。

4. **缓存**

- `HTTP缓存：` 充分利用`http`缓存做优化，依赖（不会变动的代码）部分用max-age,immutable `强缓存`，源码部分用304`协商缓存`，提升页面打开速度。
- `文件系统缓存：` `Vite`在预构建阶段，将构建后的依赖缓存到`node_modules/.vite` ，相关配置更改时，或手动控制时才会重新构建，以提升预构建速度。

5. **重写模块路径**

浏览器`import`只能引入相对/绝对路径，而开发代码经常使用`npm`包名直接引入`node_module`中的模块，需要做路径转换后交给浏览器。

- `es-module-lexer` 扫描 import 语法
- `magic-string` 重写模块的引入路径

```js
// 开发代码
import { createApp } from 'vue'

// 转换后
import { createApp } from '/node_modules/vue/dist/vue.js'
```

### 源码分析（vite@2.7.2）

与`Webpack-dev-server`类似`Vite`同样使用`WebSocket`与客户端建立连接，实现热更新，源码实现基本可分为两部分，源码位置在:

- `vite/packages/vite/src/client` client（用于客户端）
- `vite/packages/vite/src/node server`（用于开发服务器）

`client` 代码会在启动服务时注入到客户端，用于客户端对于`WebSocket`消息的处理（如更新页面某个模块、刷新页面）；`server` 代码是服务端逻辑，用于处理代码的构建与页面模块的请求。

1. 命令行启动服务`npm run dev`后，源码执行`cli.ts`，调用`createServer`方法，`创建http服务`，监听开发服务器端口。

```js
// 源码位置 vite/packages/vite/src/node/cli.ts
const { createServer } = await import('./server')
try {
    const server = await createServer({
        root,
        base: options.base,
        ...
    })
    if (!server.httpServer) {
        throw new Error('HTTP server not available')
    }
    await server.listen()
}
```

2. `createServer`方法的执行做了很多工作，如整合配置项、创建http服务（早期通过koa创建）、创建`WebSocket`服务、创建源码的文件监听、插件执行、optimize优化等。下面注释中标出。

```js
// 源码位置 vite/packages/vite/src/node/server/index.ts
export async function createServer(
    inlineConfig: InlineConfig = {}
): Promise<ViteDevServer> {
    // Vite 配置整合
    const config = await resolveConfig(inlineConfig, 'serve', 'development')
    const root = config.root
    const serverConfig = config.server

    // 创建http服务
    const httpServer = await resolveHttpServer(serverConfig, middlewares, httpsOptions)

    // 创建ws服务
    const ws = createWebSocketServer(httpServer, config, httpsOptions)

    // 创建watcher，设置代码文件监听
    const watcher = chokidar.watch(path.resolve(root), {
        ignored: [
            '**/node_modules/**',
            '**/.git/**',
            ...(Array.isArray(ignored) ? ignored : [ignored])
        ],
        ...watchOptions
    }) as FSWatcher

    // 创建server对象
    const server: ViteDevServer = {
        config,
        middlewares,
        httpServer,
        watcher,
        ws,
        moduleGraph,
        listen,
        ...
    }

    // 文件监听变动，websocket向前端通信
    watcher.on('change', async (file) => {
        ...
        handleHMRUpdate()
    })

    // 非常多的 middleware
    middlewares.use(...)
    
    // optimize
    const runOptimize = async () => {...}

    return server
}
```

3. 使用[chokidar](https://www.npmjs.com/package/chokidar)监听文件变化，绑定监听事件。

```js
// 源码位置 vite/packages/vite/src/node/server/index.ts
const watcher = chokidar.watch(path.resolve(root), {
  ignored: [
    '**/node_modules/**',
    '**/.git/**',
    ...(Array.isArray(ignored) ? ignored : [ignored])
  ],
  ignoreInitial: true,
  ignorePermissionErrors: true,
  disableGlobbing: true,
  ...watchOptions
}) as FSWatcher
```

4. 通过 [ws](https://www.npmjs.com/package/ws) 来创建WebSocket服务，用于监听到文件变化时触发热更新，向客户端发送消息。

```js
// 源码位置 vite/packages/vite/src/node/server/ws.ts
export function createWebSocketServer(...){
    let wss: WebSocket
    const hmr = isObject(config.server.hmr) && config.server.hmr
    const wsServer = (hmr && hmr.server) || server

    if (wsServer) {
        wss = new WebSocket({ noServer: true })
        wsServer.on('upgrade', (req, socket, head) => {
            // 服务就绪
            if (req.headers['sec-websocket-protocol'] === HMR_HEADER) {
                wss.handleUpgrade(req, socket as Socket, head, (ws) => {
                    wss.emit('connection', ws, req)
                })
            }
        })
    } else {
        ...
    }
    // 服务准备就绪，就能在浏览器控制台看到熟悉的打印 [vite] connected.
    wss.on('connection', (socket) => {
        socket.send(JSON.stringify({ type: 'connected' }))
        ...
    })
    // 失败
    wss.on('error', (e: Error & { code: string }) => {
        ...
    })
    // 返回ws对象
    return {
        on: wss.on.bind(wss),
        off: wss.off.bind(wss),
        // 向客户端发送信息
        // 多个客户端同时触发
        send(payload: HMRPayload) {
            const stringified = JSON.stringify(payload)
            wss.clients.forEach((client) => {
                // readyState 1 means the connection is open
                client.send(stringified)
            })
        }
    }
}
```

5. 在服务启动时会向浏览器注入代码，用于处理客户端接收到的`WebSocket`消息，如重新发起模块请求、刷新页面。

```js
//源码位置 vite/packages/vite/src/client/client.ts
async function handleMessage(payload: HMRPayload) {
  switch (payload.type) {
    case 'connected':
      console.log(`[vite] connected.`)
      break
    case 'update':
      notifyListeners('vite:beforeUpdate', payload)
      ...
      break
    case 'custom': {
      notifyListeners(payload.event as CustomEventName<any>, payload.data)
      ...
      break
    }
    case 'full-reload':
      notifyListeners('vite:beforeFullReload', payload)
      ...
      break
    case 'prune':
      notifyListeners('vite:beforePrune', payload)
      ...
      break
    case 'error': {
      notifyListeners('vite:error', payload)
      ...
      break
    }
    default: {
      const check: never = payload
      return check
    }
  }
}
```

### 优势

- 快！快！非常快！！
- 高度集成，开箱即用。
- 基于ESM急速热更新，无需打包编译。
- 基于esbuild的依赖预处理，比Webpack等node编写的编译器快几个数量级。
- 兼容Rollup庞大的插件机制，插件开发更简洁。
- 不与Vue绑定，支持React等其他框架，独立的构建工具。
- 内置SSR支持。
- 天然支持TS。

### 不足

- Vue仍为第一优先支持，量身定做的编译插件，对React的支持不如Vue强大
- 虽然已经推出2.0正式版，已经可以用于正式线上生产，但目前市场上实践少。
- 生产环境集成`Rollup`打包，与开发环境最终执行的代码不一致。

### 与 webpack 对比

由于`Vite`主打的是开发环境的极致体验，生产环境集成`Rollup`，这里的对比主要是`Webpack-dev-server`与`Vite-dev-server`的对比：

- Webpack配置丰富使用极为灵活但上手成本高，Vite开箱即用配置高度集成
- Webpack启动服务需打包构建，速度慢，Vite免编译可秒开
- Webpack热更新需打包构建，速度慢，Vite毫秒响应
- Webpack成熟稳定、资源丰富、大量实践案例，Vite实践较少
- Vite使用`esbuild`编译，构建速度比webpack快几个数量级

### 兼容性

- 默认目标浏览器是在`script`标签上支持原生 ESM 和 原生 ESM 动态导入
- 可使用官方插件 `@vitejs/plugin-legacy`，转义成传统版本和相对应的polyfill

