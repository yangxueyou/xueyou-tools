// 1. 请实现一个 EventBus 模块，可以实现自定义事件的订阅、触发、移除功能，功能如下所示

const eventBus = new EventBus();
function handleSleep1(){
console.log('sleep1');
}
function handleSleep2(){
console.log('sleep2');
}
function handleSleep3(){
console.log('sleep3');
}
// 一堆监听
eventBus.on('sleep', handleSleep1);
eventBus.on('sleep', handleSleep2);
eventBus.on('sleep', handleSleep1);
eventBus.on('sleep', handleSleep3);
// 取消一个
eventBus.off('sleep', handleSleep3);
// 触发
eventBus.emit('sleep');
// 预期正确输出是（重复监听不生效、按监听顺序执行、取消的不生效）
// sleep1
// sleep2
// 全部取消
eventBus.off('sleep');
// 触发
eventBus.emit('sleep');
// 预期的正确输出是：没有输出

// 我的代码：
class EventBus {
  constructor() {
    this.messages = {}
  }

  on(name, fn) {
    if(this.messages[name]) {
      let i = 0, isExist = false
      while(i < this.messages[name].length) {
        if(this.messages[name][i] === fn) {
          isExist = true
          break;
        }
        i++
      }
      if(!isExist) {
        this.messages[name].push(fn)
      }
    } else {
      this.messages[name] = [fn]
    }
  }

  off(name, fn) {
    if(this.messages[name]) {
      if(!fn) {
        this.messages[name] = null
        return
      }
      let i = this.messages[name].length - 1
      while(i>=0) {
        if(this.messages[name][i] === fn) {
          this.messages[name].splice(i,1)
          break;
        }
        i--
      }
    }
  }

  emit(name) {
    if(!this.messages[name]) {
      return
    }
    this.messages[name].forEach((cb) => {
      cb.call(this)
    })
  }
}


// --------------------------------------------------------

// 2. 实现一个lazyman的链式调用
LazyMan('Tony').eat('lunch').sleep(10).eat('dinner')
// 结果输出
// Hi i am Tony
// I am eating lunch
// 等待了10秒
// I am eating dinner

// 我的代码
function LazyMan(name) {
  const callbacks = []
  let state = ''
  console.log(`hi i am ${name}`)

  return {
    sleep(delay) {
      const wait = () => {
        state = 'sleeping'
        setTimeout(() => {
          console.log(`等待了${delay}s`)
          state = ''
          this.resolve()
        }, delay * 1000)
      }
      if(state !== 'sleeping') {
        wait()
      } else {
        callbacks.push(wait)
      }
      return this
    },
  
    eat(thing) {
      const sayEating = () => {
        console.log(`I am eating ${thing}`)
        this.resolve()
      }
      if(state !== 'sleeping') {
        sayEating()
      } else {
        callbacks.push(sayEating)
      }
      return this
    },
  
    resolve() {
      if(state !== 'sleeping') {
        const cb = callbacks.shift()
        cb && cb()
      }
    }
  }
}




问答题
自我介绍，说说你做的项目和亮点，以及难点
然后紧接着问和项目相关的问题，怎么做的，架构为什么这么做，有没有改进的空间
js 编译原理，介绍下 AST
事件循环机制，宏任务，微任务
node 是单线程，为什么能处理高并发
node 事件循环机制
跨域的解决方式，当然主要的就是 jsonp cors 这两种了
缓存机制，主要是问 304 和 强缓存
web 安全， 主要是 xss csrf
node 错误处理
node 服务进程守护是如何做的。pm2？（不行的）
koa 的中间件机制是什么，解决了什么问题，如何实现
如何理解前后端分离？（这里聊了得十分钟）
react ssr 实现的难点
react ssr 如何区分服务端环境还是客户端环境
多实例如何保存登录态，也就是 session 如何存储
快应用和微信小程序的底层机制区别
常用设计模式有哪些，具体应用场景是什么
数据库死锁如何解决
介绍下消息队列以及应用
说说对 mvvm 的理解



