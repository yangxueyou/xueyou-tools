### 看一下

下面就是我们的 .env 文件

```
 # Licensed to the Apache Software Foundation (ASF) under one or more
 # contributor license agreements.  See the NOTICE file distributed with
 # this work for additional information regarding copyright ownership.
 # The ASF licenses this file to You under the Apache License, Version 2.0
 # (the "License"); you may not use this file except in compliance with
 # the License.  You may obtain a copy of the License at
 #
 #     http://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.

# back end interface address
API_BASE = http://127.0.0.1:12345

# host and port for local development
 DEV_HOST = 127.0.0.1
# DEV_PORT = 8888
```

### what？

Q：在很多项目里的根路径中老能看见 .env 文件，这个到底是干啥的?

A：区分环境变量的。

### 怎么用

```js
// 创建好文件，安装依赖
$ yarn add dotenv
// 尽可能早的去加载下面这段话
require('dotenv').config()
console.log(process.env) // 测试完就可以删除了
```

然后在 `.env` 中写的 `key-value`，就可以被 `process.env` 读取到了

### 组件项目结构

创建一个 env_config.js 文件

```js
const dotenv = require（'dotenv'）;

dotenv.config（）;

module.exports = {
  API_BASE: process.env.API_BASE,
  DEV_HOST: process.env.DEV_HOST,
  DEV_PORT: process.env.DEV_PORT
}；
```

然后就可以这样进行使用：

```js
const { DEV_PORT } = require（'./env_config'）;
console.log（`端口为：$ {DEV_PORT}`）;
```

### 封装

https://www.npmjs.com/package/env-parse

```js
const getEnv = require("env-parse").getEnv;
getEnv("DEV_HOST", "localhost"); // 如果 .env 没有 DEV_HOST，就返回 localhost
```

### 封装源码

```js
/**
 * Env parser
 *
 * @author Allex Wang (allex.wxn@gmail.com)
 */

"use strict";

var _typeof =
  typeof Symbol === "function" && typeof Symbol.iterator === "symbol"
    ? function (obj) {
        return typeof obj;
      }
    : function (obj) {
        return obj &&
          typeof Symbol === "function" &&
          obj.constructor === Symbol &&
          obj !== Symbol.prototype
          ? "symbol"
          : typeof obj;
      };

var fs = require("fs");
var path = require("path");
var dotenv = require("dotenv");
var parse = dotenv.parse;
var extend = require("util")._extend;

var DEFAULT_DOT_FILE = ".env";
var PATH_SEP = path.sep;

// Parses dotenv file
// Returns a variables mapping
var parseFile = function parseFile(file, encoding) {
  var envConfig = dotenv.parse(fs.readFileSync(file, encoding || "utf8"));
  return envConfig;
};

var findEnvFile = function findEnvFile(root, dotfile) {
  if (typeof root === "string") {
    if (root[root.length - 1] !== PATH_SEP) {
      root += PATH_SEP;
    }
    root = root.split(PATH_SEP);
  }

  if (!root.length) {
    return "";
  }

  root.pop();

  var f = path.join(root.join(PATH_SEP), dotfile);
  if (fs.existsSync(f)) {
    return f;
  }

  return findEnvFile(root, dotfile);
};

var _loaded = false;

var loadEnv = function loadEnv(file) {
  var options =
    arguments.length <= 1 || arguments[1] === undefined
      ? { encoding: "utf8", overwrite: true }
      : arguments[1];

  if (
    !file ||
    (typeof file === "undefined" ? "undefined" : _typeof(file)) === "object" ||
    !fs.existsSync(file)
  ) {
    options = file ? extend(options, file) : options;
    file = findEnvFile(
      process.cwd(),
      typeof file === "string" ? file : DEFAULT_DOT_FILE
    );
    if (!file) {
      return null;
    }
  }

  var encoding = options.encoding || "utf8";
  if (!options.overwrite) {
    return dotenv.load(file, { encoding: encoding });
  }
  var envs = parseFile(file, encoding);
  for (var k in envs) {
    process.env[k] = envs[k];
  }

  _loaded = true;

  // Implements dotenv.load specs
  return { parsed: envs };
};

// Patch env variables.
var getEnvParam = function getEnvParam(k, defval) {
  if (!_loaded) {
    loadEnv();
  }

  var v = process.env[k],
    type = "string";
  if (defval != null) {
    type = typeof defval === "undefined" ? "undefined" : _typeof(defval);
  }
  if (v == null) v = defval;
  else if (type !== "string") {
    // type cast
    switch (type) {
      case "number":
        v = parseFloat(v, 10);
        break;
      case "boolean":
        v =
          v === "1" || v === "true" || v === "on" || v === "yes" ? true : false;
        break;
    }
  }
  return v;
};

/**
 * @see {dotenv.parse}
 */
exports.parse = parse;

/**
 * Load and parse dotenv file, Returns a env variables object.
 */
exports.parseFile = parseFile;

/**
 * Load dotenv file and apply to envs.
 * Optional set {options.overwrite} to indicate whether overwrite the exists envs.
 * (Defaults to true)
 *
 * @seealso {dotenv.load}
 */
exports.loadEnv = loadEnv;

/**
 * Get env variable by env key name, provide default value.
 * The returns typle will follow the type of the default value.
 *
 * @param {String} key The evn key name
 * @param {Mixed} defval (Optional) provide a default value if not found.
 *
 * @example
 *
 * process.env['WEB_SSL'] = '1';
 *
 * require('env-parse').getEnv('WEB_SSL', false)
 *  ->  true
 *
 * require('env-parse').getEnv('WEB_SSL', 0)
 *  -> 1
 */
exports.getEnv = getEnvParam;

/**
 * Set a specific enviroment variable value, the value will cast to string by
 * default.
 *
 * Note: This api will overwrite these values defined in `.env`
 */
exports.setEnv = function (k, v) {
  if (!_loaded) {
    loadEnv();
  }

  if (v == null) v = "";
  else v = String(v);

  process.env[k] = v;
};
```
