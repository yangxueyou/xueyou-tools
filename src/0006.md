### HTML & CSS

#### 1. 一个 DOM 元素同时拥有多个类名时的样式

```
  <style>
    .m1{color:white;border: 1px solid red; margin-top: 20px;}
    .m2{background-color: blue;border: 10px solid yellow;}
  </style>
  <div class="m1 m2">1</div>
  <div class="m2 m1">2</div>
```

**请问效果最终是怎样的？** 如下：

https://upload-images.jianshu.io/upload_images/11996357-6bdccf6e715cec32.png

**参考**：
https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity

#### 2. rem 和 em 区别 -- 2021/02/24

https://zhuanlan.zhihu.com/p/28915418

#### 3. 介绍盒模型一下 -- 2021/02/24

```
box-sizing: content-box 是W3C盒子模型   正常
元素的width和height属性只包含内容content部分，不包含内边距padding和边框border部分。
```

```
box-sizing: border-box 是IE盒子模型   怪异
元素的width和height属性同时包含内容content，内边距padding和边框border部分
```

#### 4. flex: 0 1 auto; 是什么意思

三个参数分别对应的是 flex-grow, flex-shrink 和 flex-basis，默认值为 0 1 auto。

1.flex-grow 属性定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大。

2.flex-shrink 属性定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。

3.flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。

`请不要分开写`

http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html

#### 5. less 的 & 代表什么

重复所有的祖先选择器，而不是仅仅重复最近的父选择器

https://www.jianshu.com/p/127b0974cfc3

### JavaScript

#### 1. derfer 和 async 的区别

https://www.cnblogs.com/zjp-zxy/p/9552809.html

#### 2. 节流防抖的原理和使用场景

```js
防抖: 每次触发事件时都取消之前的延时调用方法
function debounce(fn) {
  let timeout = null; // 创建一个标记用来存放定时器的返回值
  return function () {
    clearTimeout(timeout); // 每当用户输入的时候把前一个 setTimeout clear 掉
    timeout = setTimeout(() => {
    // 然后又创建一个新的 setTimeout,
    // 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数
    fn.apply(this, arguments);
   }, 500);
 };
}
function sayHi() {
  console.log('防抖成功');
}

var inp = document.getElementById('inp');
inp.addEventListener('input', debounce(sayHi)); // 防抖

节流: 高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率
function throttle(fn) {
  let canRun = true; // 通过闭包保存一个标记
  return function () {
    if (!canRun) return; // 在函数开头判断标记是否为true，不为true则return
    canRun = false; // 立即设置为false
    setTimeout(() => { // 将外部传入的函数的执行放在setTimeout中
     fn.apply(this, arguments);
     // 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。
     // 当定时器没有执行的时候标记永远是false，在开头被return掉
     canRun = true;
    }, 500);
  };
}
function sayHi(e) {
 console.log(e.target.innerWidth, e.target.innerHeight);
}
window.addEventListener('resize', throttle(sayHi));
```

```
应用场景:
debounce
1. 登录、发短信等按钮避免用户点击太快，以致于发送了多次请求，需要防抖
2. 调整浏览器窗口大小时，resize 次数过于频繁，造成计算过多，此时需要一次到位，就用到了防抖
3. 文本编辑器实时保存，当无任何更改操作一秒后进行保存
throttle
1. scroll 事件，每隔一秒计算一次位置信息等
2. 浏览器播放事件，每隔一秒计算一次进度信息等
3. input框实时搜索并发送请求展示下拉列表，每隔一秒发送一次请求 (也可做防抖)
```

#### 3. 手写 Promise

https://juejin.cn/post/6850037281206566919

https://www.zhihu.com/question/41986174/answer/93340999

#### 4. 介绍一下 ES6

https://es6.ruanyifeng.com/

#### 5. 写出下面输出结果

```
async function async1() {
    console.log('async1 start');
    await async2();
    console.log('async1 end');
}
async function async2() {
    console.log('async2');
}
console.log('script start');
setTimeout(function() {
    console.log('setTimeout');
}, 0)
async1();
new Promise(function(resolve) {
    console.log('promise1');
    resolve();
}).then(function() {
    console.log('promise2');
});
console.log('script end');
```

#### 6.setTimeout、Promise、Async/Await 的区别

```
事件循环中分为宏任务队列和微任务队列。

其中settimeout的回调函数放到宏任务队列里，等到执行栈清空以后执行；

promise.then里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行；

async函数表示函数里面可能会有异步方法，await后面跟一个表达式，async方法执行时，
遇到await会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行。
```

#### 7. 原型链

https://github.com/mqyqingfeng/Blog/issues/2

#### 8. 继承

https://segmentfault.com/a/1190000022677985

#### 9. 柯里化

https://cloud.tencent.com/developer/article/1664434

#### 10. 闭包

https://juejin.cn/post/6937469222251560990#comment

#### 11. JSONP

可以跨越吗？JSONP 跨域的原理

只能是 get 请求

JSONP 是通过动态`<script>`元素使用的，可以为`src`属性指定一个跨域 URL，`<script>`有能力从其他域加载资源。

#### 12. 两次上传同样的文件怎么触发 onchange

```
一个<input type="file"/>两次上传同样的文件怎么触发onchange,用react怎么实现。
```

https://blog.csdn.net/cc18868876837/article/details/89194641

#### 13. fetch 发送 2 次请求的原因

https://blog.csdn.net/fyp_1995/article/details/89973824

#### 14. 怎么访问到 arr[-1]

```
1. proxy
2. valueOf
3. toString
```

#### 15. 实现斐波那契数列

```
function* fibonacci() {
  let [prev, curr] = [0, 1];
  for (;;) {
    yield curr;
    [prev, curr] = [curr, prev + curr];
  }
}

for (let n of fibonacci()) {
  if (n > 1000) break;
  console.log(n);
}
```

#### 16. 遍历任意对象（object）的方法

```js
function* objectEntries(obj) {
  let propKeys = Reflect.ownKeys(obj);

  for (let propKey of propKeys) {
    yield [propKey, obj[propKey]];
  }
}

let jane = { first: "Jane", last: "Doe" };

for (let [key, value] of objectEntries(jane)) {
  console.log(`${key}: ${value}`);
}
// first: Jane
// last: Doe
```

#### 17. 请实现一个 EventBus 模块

可以实现自定义事件的订阅、触发、移除功能，功能如下所示

```js
const eventBus = new EventBus();
function handleSleep1() {
  console.log("sleep1");
}
function handleSleep2() {
  console.log("sleep2");
}
function handleSleep3() {
  console.log("sleep3");
}
// 一堆监听
eventBus.on("sleep", handleSleep1);
eventBus.on("sleep", handleSleep2);
eventBus.on("sleep", handleSleep1);
eventBus.on("sleep", handleSleep3);
// 取消一个
eventBus.off("sleep", handleSleep3);
// 触发
eventBus.emit("sleep");
// 预期正确输出是（重复监听不生效、按监听顺序执行、取消的不生效）
// sleep1
// sleep2
// 全部取消
eventBus.off("sleep");
// 触发
eventBus.emit("sleep");
// 预期的正确输出是：没有输出
```

```js
// 我的代码：
class EventBus {
  constructor() {
    this.messages = {};
  }

  on(name, fn) {
    if (this.messages[name]) {
      let i = 0,
        isExist = false;
      while (i < this.messages[name].length) {
        if (this.messages[name][i] === fn) {
          isExist = true;
          break;
        }
        i++;
      }
      if (!isExist) {
        this.messages[name].push(fn);
      }
    } else {
      this.messages[name] = [fn];
    }
  }

  off(name, fn) {
    if (this.messages[name]) {
      if (!fn) {
        this.messages[name] = null;
        return;
      }
      let i = 0;
      while (i < this.messages[name].length) {
        if (this.messages[name][i] === fn) {
          this.messages[name].splice(i, 1);
          break;
        }
        i++;
      }
    }
  }

  emit(name) {
    if (!this.messages[name]) {
      return;
    }
    this.messages[name].forEach((cb) => {
      cb()
    });
  }
}
```

#### 18. 实现一个 lazyman 的链式调用

```js
LazyMan("Tony").eat("lunch").sleep(10).eat("dinner");
// 结果输出
// Hi i am Tony
// I am eating lunch
// 等待了10秒
// I am eating dinner
```

```js
// 我的代码
function LazyMan(name) {
  const callbacks = [];
  let state = "";
  console.log(`hi i am ${name}`);

  return {
    sleep(delay) {
      const wait = () => {
        state = "sleeping";
        setTimeout(() => {
          console.log(`等待了${delay}s`);
          state = "";
        }, delay * 1000);
      };
      if (state !== "sleeping") {
        wait();
      } else {
        callbacks.push(wait);
      }
      return this;
    },

    eat(thing) {
      const sayEating = () => {
        console.log(`I am eating ${thing}`);
      };
      if (state !== "sleeping") {
        sayEating();
      } else {
        callbacks.push(sayEating);
      }
      return this;
    },

    resolve() {
      if (state !== "sleeping") {
        callbacks.forEach((cb) => {
          cb();
        });
      }
    },
  };
}
```

### React

#### 1. React 中 setState 是同步的还是异步

https://juejin.im/post/6844903636749778958

#### 2. React 事件绑定原理

https://github.com/lgwebdream/FE-Interview/issues/23

#### 3. Redux 和 Mobx 对比

https://blog.csdn.net/wang839305939/article/details/87908123

#### 4. react 16/17 生命周期有什么改变

https://reactjs.bootcss.com/docs/react-component.html#constructor

#### 5. react.lazy 动态加载的原理

https://juejin.cn/post/6844904167664795662

#### 6. redux 如何改变状态

```
当一个action被执行的时候，我们可以去改变状态。

假设如下流程:

用户点击一个按钮

一个函数会被调用

一个action会被发出给处理容器， 这个容器需要用map dispatch to props来注册这个action。

Reducer会根据action来改变状态。

状态的改变会被处理容器注意到, map state to props。
```

#### 7. 解释一下 redux 里面的 store

```
Store存放应用程序的状态，并且有帮助函数来访问这些状态。

Store可以用来聆听变化和发送action。

Store只有一个。

你可以创建很多sub stores。
```

#### 8. 解释一下 redux 里面的 reducers

```
数据的状态是通过reducer函数来改变的。
```

#### 9. 解释一下 redux 里面的 actions

```
Actions代表的是一个对象。有两部分，一个是action本身，另一个就是它的payload。
简单说就是对哪些数据进行哪些操作。
```

#### 10. react-hook 的 useMemo 和 useCallBack 有什么区别

https://github.com/yangxueyou/hooks/blob/main/src/useMemo.js

### Vue

#### 1. Vue 的响应式原理中 Object.defineProperty 有什么缺陷？

```
1、无法监听es6的Set、Map变化

2、无法监听Class类型的数据

3、属性的新增或删除无法监听

4、数组原数的增加和删除也无法监听

proxy对IE11及以下版本不太友好:
  所以vue3在检测到如果是ie、会自动降级为Object.defineProperty的数据监听系统
```

### Vue 和 React

#### 1. Vue 和 React 的优点分别是什么

https://www.zhihu.com/question/301860721/answer/545031906

https://www.zhihu.com/question/294210442/answer/491636672

### Node

#### 1. node 环境和 chrome 运行环境的区别

https://www.jianshu.com/p/254adf363e19

#### 2. Chrome 与 Node 的事件循环(Event Loop)有何区别

Chrome 和 node: https://juejin.cn/post/6844903761949753352

Chrome: https://juejin.cn/post/6844903802185711629

#### 3. vite VS webpack

https://blog.csdn.net/qq_41499782/article/details/109593388

#### 4. webpack 性能优化有哪些

https://juejin.cn/post/6940160221339713567

### Chrome & Network

#### 1. 从输入 URL 到页面展示，这中间发生了什么

https://xie.infoq.cn/article/ecfa81d2fc00c33b32167a536

#### 2. Http: 301 和 302 的应用场景分别是什么

```
对于用户来说没有什么区别，都是从一个旧地址跳转到了一个新地址

内容指向了新地址，主要区别在搜索引擎

301: 认为旧地址不会再用到，会把地址跟内容都更新成新地址及其内容

302: 搜索引擎认为跳转只是临时的，保留旧地址，抓取新的内容。

```

#### 3. Cookie 和 Session 有什么区别

（1）Session 是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；

（2）Cookie 是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现 Session 的一种方式。

#### 4. 请解释 http1.0/2.0/3.0

https://www.jianshu.com/p/7aed7a584a8f

#### 5. TCP、UDP 是什么？它们的实现过程

https://zhuanlan.zhihu.com/p/60017840

#### 6. “重排”、“重绘”、“合成”

- 重排

更新了元素的几何属性

重排需要更新完整的渲染流水线，所以开销也是最大的

- 重绘

更新元素的绘制属性

重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。

- 合成

使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，

跳过布局、分层和绘制列表阶段，

相对于重绘和重排，合成能大大提升绘制效率。

- 减少重排重绘的方法很多：

1. 使用 class 操作样式，而不是频繁操作 style
2. 避免使用 table 布局
3. 批量 dom 操作，例如 createDocumentFragment，或者使用框架，例如 React
4. Debounce window resize 事件
5. 对 dom 属性的读写要分离
6. will-change: transform 做优化

### 算法

#### 1. 排序

问题：在一个字符串数组中有红、黄、蓝三种颜色的球，且个数不相等、顺序不一致，请为该数组排序。使得排序后数组中球的顺序为:黄、红、蓝。

例如：红蓝蓝黄红黄蓝红红黄红，排序后为：黄黄黄红红红红红蓝蓝蓝。

```js
let arr = "红黄蓝蓝红黄红蓝黄红黄红黄".split("");
let obj = { 黄: 0, 红: 1, 蓝: 2 };
arr.sort((prev, next) => obj[prev] - obj[next]);
```

#### 2. 取值

问题：数组里面有 10 万个数据，取第一个元素和第 10 万个元素的时间相差多少

```
JavaScript 没有真正意义上的数组，
所有的数组其实是对象，其“索引”看起来是数字，
其实会被转换成字符串，作为属性名（对象的 key）来使用。
所以无论是取第 1 个还是取第 10 万个元素，都是用 key 精确查找哈希表的过程，其消耗时间大致相同。
```

### 项目

#### 1. OAuth2

http://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html

#### 2. 单点登陆

https://mp.weixin.qq.com/s/8qJt8i_DSXY5zDh2ir_2gw

### 福利

#### 1. 简历怎么写

https://juejin.cn/post/6921890174842454023
